use pest_consume::{ Parser, match_nodes, Error};

#[derive(Parser)] // This allows Pest to add all the parse methods
#[grammar = "basic.pest"]
struct BasicParser;

// Pull in the model
use crate::*;

// Some type simplifications, for brevity
type Result<T> = std::result::Result<T, Error<Rule>>;
type Node<'i> = pest_consume::Node<'i, Rule, ()>;
type Nodes<'i> = pest_consume::Nodes<'i, Rule, ()>;

struct Block {
    content: String
}

pub fn parse_source(source: &str, options: &ParseOptions) -> Result<()> {
    let nodes = BasicParser::parse(Rule::program, source)?;
    let main_node = nodes.single()?;

    if options.pretty_print {
        print_node(main_node.clone());
    }

    // BasicParser::program(main_node)?;

    Ok(())
}

// This is the other half of the parser, using pest_consume
// It traverses the Node tree generated by Pest (Nodes are a wrapper around Pest Pairs)
// and generates custom structures (MibInfo and friends) that represents the content of the MIB
#[pest_consume::parser]
impl BasicParser {
    fn EOI(_node: Node) -> Result<()> {
        Ok(())
    }

    fn program(node: Node) -> Result<()> {
        Ok(match_nodes!(node.into_children();
            [block(mut blocks)..,end_line(_)] => blocks.for_each(|b| println!("{}", b.content)),
        ))
    }

    fn block(node: Node) -> Result<Block> {
        Ok(Block{content: node.as_str().to_owned()})
    }

    fn line_number(node: Node) -> Result<u16> {
        node.as_str().parse::<u16>().map_err(|e| node.error(e))
    }

    fn end_line(node: Node) -> Result<()> {
        Ok(())
    }

    fn end_statement(node: Node) -> Result<()> {
        Ok(())
    }

    fn numeric_rep(node: Node) -> Result<f64> {
        node.as_str().parse::<f64>().map_err(|e| node.error(e))
    }
}

//
// Helpers to print a readable parse tree, mainly for debug purposes
//

fn print_node(node: Node) {
    print_single_node(&node);
    print_nodes(node.children(), 1)
}

fn print_nodes(nodes: Nodes, level: usize) {
    for node in nodes {
        // A node is a combination of the rule which matched and a span of input
        print!("{:indent$}", "", indent=level*2);
        print_single_node(&node);

        // A node can be converted to an iterator of the tokens which make it up:
        print_nodes(node.children(), level+1);
    }
}

fn print_single_node(node: &Node) {
    let text = node.as_str().to_owned().trim().to_owned();
    let rule = node.as_rule();

    if text.len() < 32 {
        println!("<{:?}> {}", rule, text)
    } else {
        println!("<{:?}> ...", rule)
    }  
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn program1() {
        let _node = BasicParser::program(parse(Rule::program, "999 END")).unwrap();
    }

    #[test]
    fn program2() {
        let source = r#"10 REM This is a simple program
20 END"#;
        let _node = BasicParser::program(parse(Rule::program, source)).unwrap();
    }
    #[test]
    fn program3() {
        // Must have an end
        parse_fail(Rule::program, "10 REM This is a simple program");
    }

    #[test]
    fn program4() {
        // No spaces before line numbers
        let source = r#"10 REM This is a simple program
 20 END"#;
        parse_fail(Rule::program, source);
    }

    #[test]
    fn program5() {
        // Must have an END
        let source = r#"10 REM This is a simple program
"#;
        parse_fail(Rule::program, source);
    }

    #[test]
    fn numeric_let1() {
        let _node = parse(Rule::numeric_let_statement, "LET S=SQR(N)");
    }

    #[test]
    fn numeric_let2() {
        let _node = parse(Rule::numeric_let_statement, "LET P = 3.14159");
    }

    #[test]
    fn numeric_let3() {
        let _node = parse(Rule::numeric_let_statement, "LET A(X,3) = SIN(X)*Y + 1");
    }

    #[test]
    fn string_let1() {
        let _node = parse(Rule::string_let_statement, "LET A$ = \"ABC\"");
    }

    #[test]
    fn string_let2() {
        let _node = parse(Rule::string_let_statement, "LET A$ = B$");
    }


    #[test]
    fn def_statement1() {
        let _node = parse(Rule::def_statement, "DEF FNF(X) = X^4 - 1");
    }

    #[test]
    fn def_statement2() {
        let _node = parse(Rule::def_statement, "DEF FNP = 3.14159");
    }

    #[test]
    fn def_statement3() {
        let _node = parse(Rule::def_statement, "DEF FNA(X) = A*X + B");
    }

    #[test]
    fn goto() {
        let _node = parse(Rule::goto_statement, "GOTO 999");
        let _node = parse(Rule::goto_statement, "GO TO 999");
    }  

    #[test]    
    fn gosub() {
        let _node = parse(Rule::gosub_statement, "GOSUB 22");
        let _node = parse(Rule::gosub_statement, "GO SUB 22");
    }

    #[test]    
    fn if1() {
        let _node = parse(Rule::if_then_statement, "IF X > Y+83 THEN 200");
    }

    #[test]    
    fn if2() {
        let _node = parse(Rule::if_then_statement, "IF A$ <> B$ THEN 550");
    }

    #[test]    
    fn on_goto() {
        let _node = parse(Rule::on_goto_statement, "ON L+1 GO TO 300,400,500");
    }

    #[test]    
    fn print() {
        let _node = parse(Rule::print_statement, r#"PRINT X"#);
        let _node = parse(Rule::print_statement, r#"PRINT X; (X+Z)/2"#);
        let _node = parse(Rule::print_statement, r#"PRINT"#);
        let _node = parse(Rule::print_statement, r#"PRINT TAB(10); A$; "IS DONE.""#);
        let _node = parse(Rule::print_statement, r#"PRINT "X EQUALS", 10"#);
        let _node = parse(Rule::print_statement, r#"PRINT X, Y"#);
        let _node = parse(Rule::print_statement, r#"PRINT ,,,X"#);
    }

    #[test]    
    fn input() {
        let _node = parse(Rule::input_statement, "INPUT X");
        let _node = parse(Rule::input_statement, "INPUT X, A$, Y(2)");
        let _node = parse(Rule::input_statement, "INPUT A, B, C");
    }

    #[test]    
    fn read() {
        let _node = parse(Rule::read_statement, "READ X");
        let _node = parse(Rule::read_statement, "READ X, Y, Z");
        let _node = parse(Rule::read_statement, "READ X(1), A$, C");
    }

    #[test]
    fn data() {
        let _node = parse(Rule::data_statement, r#"DATA 3.14159, PI, 5E-10, ",""#);
    }

    #[test]
    fn unquoted_string() {
        let _node = parse(Rule::unquoted_string, "DATA");
        let _node = parse(Rule::unquoted_string, "DA TA");
        let _node = parse(Rule::unquoted_string, "3.14159");
    }

    #[test]
    fn dimension() {
        let _node = parse(Rule::dimension_statement, "DIM A (6), B(10,10)");
        let _node = parse(Rule::dimension_statement, "DIM A(6,2)");
    }

    #[test]
    fn line_number() {
        let _node = parse(Rule::line_number, "1 ");
        let _node = parse(Rule::line_number, "10 ");
        let _node = parse(Rule::line_number, "123 ");
        let _node = parse(Rule::line_number, "1234 ");
    }


    #[test]
    fn numeric_expression() {     
        num_exp("1");
        num_exp("-1");
        num_exp("1 * 2");
        num_exp("1 * (-2)");
        num_exp("1 + 2 + 3 + 4 + 5 + 6");
        num_exp("1 + (2 + (3 + (4 + (5 + 6))))");
        num_exp("1 - 2 * 3 + 4 / 5 ^ 2");

        num_exp("1");
        num_exp(".2");
        num_exp("1.2");
        num_exp("1.2E-3");
    }

    #[test]
    fn numeric_rep() {
        num_rep("1", 1.0);
        num_rep("1.2", 1.2);
        num_rep(".1", 0.1);
        num_rep("2.345", 2.345);
        num_rep("3.14159", 3.14159);
        num_rep("122E+14", 122E+14);
    }

    fn num_rep(input: &str, expected: f64) {
        let node = parse(Rule::numeric_rep, input);
        let value = BasicParser::numeric_rep(node).unwrap();
        assert_eq!(value, expected)
    }

    fn num_exp(input: &str) {
        let node = parse(Rule::numeric_expression, input);
        print_node(node)
    }
 
    #[test]
    fn line_number_fail() {
        parse_fail(Rule::line_number, "12345 ");
    }   

    //
    // test helpers
    //
    fn parse(rule: Rule, input: &str) -> Node {
        match BasicParser::parse(rule, input) {
            Ok(nodes) => {
                let node = nodes.single().unwrap();
                assert_eq!(node.as_rule(), rule);
                if node.as_str() != input {
                    println!("Expected rule({:?}) to fully consume '{}' but only matched '{}'", rule, input, node.as_str());
                    print_node(node);
                    panic!("Failed test");
                }
                node 
            },
            Err(e) => panic!("Parse failed: {}", e)
        }
    }

    fn parse_fail(rule: Rule, input: &str) {
        assert!(BasicParser::parse(rule, input).is_err(), "Expected rule({:?}) to fail to parse '{}'", rule, input);
    }
}